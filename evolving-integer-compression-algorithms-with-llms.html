<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Evolving Integer Compression Algorithms with LLMs</title>

    <meta property="og:title" content="Evolving Integer Compression Algorithms with LLMs" />




  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2025-08-02T00:00:00.000Z" />

  <meta property="profile:first_name" content="Mathieu">
  <meta property="profile:last_name" content="Larose">


<meta property="og:url" content="https://mathieularose.com/evolving-integer-compression-algorithms-with-llms" />


    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"
    />
    <link rel="stylesheet" href="./main.css" />
    <link rel="me" href="https://mastodon.social/@mathieularose" />
    <link
      href="/atom.xml"
      rel="alternate"
      title="Mathieu Larose"
      type="application/atom+xml"
    />
  </head>

  <body class="">
    <header class="">
  <h1>Mathieu Larose</h1>

  <nav>
    <ul>
      <li><a href="/" class="">Home</a></li>
      <li><a href="/services" class="">Services</a></li>
      <li><a href="/projects" class="">Projects</a></li>
    </ul>
  </nav>
</header>
 

<main>
  <hgroup>
    <h1>Evolving Integer Compression Algorithms with LLMs</h1>
    <p>August 2025</p>
  </hgroup>

  <p>A few weeks ago I released <a href="https://github.com/larose/optiverse">Optiverse</a>, an open-source implementation of DeepMind's <a href="https://deepmind.google/discover/blog/alphaevolve-a-gemini-powered-coding-agent-for-designing-advanced-algorithms/">AlphaEvolve</a>.</p>
<p>My first experiment was a classic optimization problem: the <a href="https://github.com/larose/optiverse/tree/main/examples/tsp">Traveling Salesman Problem (TSP)</a>. After exploring TSP, I wanted to test Optiverse on a more low-level and performance-critical problem. For my second experiment, I worked on compressing sorted integers.</p>
<p>In search engines, searching for a word returns a list of document IDs (integers) that are naturally sorted in increasing order to make processing faster. These integers must be stored and accessed efficiently.</p>
<p>I decided to try this in Go.</p>
<p>In the end, it produced a state-of-the-art implementation better than several C implementations, though not better than the very best ones.</p>
<p>The full code is available in the Optiverse repo: <a href="https://github.com/larose/optiverse/tree/main/examples/integer_compression">https://github.com/larose/optiverse/tree/main/examples/integer_compression</a></p>
<h2>Problem Description</h2>
<p>Here's the exact problem and constraints I gave to Optiverse:</p>
<p>Design and implement a compression algorithm for sorted 32-bit unsigned integers in Go by completing the two function stubs provided below.</p>
<p>Your primary goal is to achieve the lowest possible decompression time while also maintaining a competitive compression ratio and reasonable compression time.</p>
<p>To be competitive, your solution must surpass traditional methods like Variable Byte (VByte), PForDelta, and VTEnc. Drawing inspiration from these or related techniques is allowed, but mere reimplementation is insufficient. True innovation is required.</p>
<p>You are encouraged to explore novel approaches based on well-known general patterns, including but not limited to:</p>
<ul>
<li>Delta Encoding and Delta-of-Delta</li>
<li>Bit-Packing and Frame-of-Reference</li>
<li>Headerless or Self-Describing Formats</li>
<li>Table-Driven and SIMD-Accelerated Decoding</li>
<li>Block-based or chunked compression with skippable blocks</li>
</ul>
<h2>Requirements</h2>
<p>Implement the following two functions with these exact signatures:</p>
<pre class="hljs"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compress</span><span class="hljs-params">(data []<span class="hljs-type">uint32</span>)</span></span> []<span class="hljs-type">byte</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Decompress</span><span class="hljs-params">(compressed []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">uint32</span>
</code></pre>
<p>You may define additional package-level helper functions (no nested functions).</p>
<p>Use only the Go Standard Library. Third-party packages are not allowed.</p>
<p>The use of built-in compression libraries (compress/gzip, flate, zlib, lzw, etc.) is strictly prohibited.</p>
<p>The output of <code>Decompress(Compress(data))</code> must exactly match the original <code>data</code>.</p>
<p>You may assume that:</p>
<ul>
<li>The input to <code>Compress</code> (<code>data</code>) is valid and strictly increasing.</li>
<li>The input to <code>Decompress</code> (<code>compressed</code>) is valid and was produced by a correct call to <code>Compress</code>.</li>
</ul>
<h2>What the LLM Discovered</h2>
<p>As you can see, I prompted the LLM to go beyond traditional approaches, and I even suggested SIMD (Single Instruction, Multiple Data), a form of parallelism offered by the CPU for free. But since Go lacks built-in SIMD support and I didn't allow third-party libraries, it didn't go that route.</p>
<p>That said, to be truly competitive, SIMD would likely have been necessary.</p>
<p>What it did produce is a delta-based compression implementation, which is a core part of all state-of-the-art implementations. It takes advantage of the fact that compressing the deltas (i.e., differences) between sorted integers reduces space and improves speed. This works well because deltas are usually much smaller than the original integers, and smaller values require fewer bits to encode.</p>
<p>Building on this, the algorithm applies block-based encoding with bit-packing. Here's how it works:</p>
<ul>
<li>Divide the deltas into fixed-size blocks.</li>
<li>For each block, find the maximum delta.</li>
<li>Compute how many bits are needed to represent that max delta.</li>
<li>Encode each delta in the block using that fixed bit width.</li>
</ul>
<p>You'll find the full Go implementation in the appendix.</p>
<h2>Benchmark Results</h2>
<p>I compared the Go implementation generated by Optiverse against a few C implementations using this <a href="https://github.com/vteromero/integer-compression-benchmarks">benchmark</a>.</p>
<table class="post-table mb-4"><thead>
<tr>
<th>Algorithm</th>
<th>Decoding Speed (GB/s)</th>
<th>Compression Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>VTEnc</td>
<td>8.1</td>
<td>26,622</td>
</tr>
<tr>
<td>Delta+VarIntGB</td>
<td>7.9</td>
<td>3.2</td>
</tr>
<tr>
<td><strong>Delta+BinaryPacking (Optiverse)</strong></td>
<td><strong>5.7</strong></td>
<td><strong>230</strong></td>
</tr>
<tr>
<td>Delta+BinaryPacking (C)</td>
<td>5.2</td>
<td>127</td>
</tr>
<tr>
<td>Delta+FastPFor128</td>
<td>4.4</td>
<td>250</td>
</tr>
<tr>
<td>Delta+FastPFor256</td>
<td>4.2</td>
<td>489</td>
</tr>
<tr>
<td>Delta+VariableByte</td>
<td>4.4</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>(Higher = better on both metrics)</p>
<p>CPU: Intel Core i5-6500T @ 2.50GHz</p>
<h2>Conclusion</h2>
<p>This experiment showed how capable LLMs can be when guided right. Even though it didn’t find a new algorithm, Optiverse came up with a fast, practical solution by trying known ideas like delta encoding and bit packing. It probably tried some bad or made up ideas, but the process filtered those out and kept what worked. In that way, it acted like an agent, trying things and learning as it went.</p>
<h2>Appendix</h2>
<h3>Full Go Implementation</h3>
<p>This solution was discovered after ~1000 iterations using Qwen3-235B-A22B with Optiverse.</p>
<pre class="hljs"><code class="hljs"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;encoding/binary&quot;</span>
	<span class="hljs-string">&quot;math/bits&quot;</span>
)

<span class="hljs-keyword">const</span> blockSize = <span class="hljs-number">128</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compress</span><span class="hljs-params">(data []<span class="hljs-type">uint32</span>)</span></span> []<span class="hljs-type">byte</span> {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	}

	compressed := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)
	binary.LittleEndian.PutUint32(compressed[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>], data[<span class="hljs-number">0</span>])
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">1</span> {
		<span class="hljs-keyword">return</span> compressed[:<span class="hljs-number">4</span>]
	}

	deltas := <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint32</span>, <span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>)
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> deltas {
		deltas[i] = data[i+<span class="hljs-number">1</span>] - data[i]
	}
	binary.LittleEndian.PutUint32(compressed[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>], <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(deltas)))

	pos := <span class="hljs-number">8</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(deltas); i += blockSize {
		end := i + blockSize
		<span class="hljs-keyword">if</span> end &gt; <span class="hljs-built_in">len</span>(deltas) {
			end = <span class="hljs-built_in">len</span>(deltas)
		}
		block := deltas[i:end]

		maxDelta := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>)
		<span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> block {
			<span class="hljs-keyword">if</span> d &gt; maxDelta {
				maxDelta = d
			}
		}

		bitsPerDelta := <span class="hljs-number">0</span>
		<span class="hljs-keyword">if</span> maxDelta &gt; <span class="hljs-number">0</span> {
			bitsPerDelta = bits.Len32(maxDelta)
		}
		bytesPerDelta := <span class="hljs-number">0</span>
		<span class="hljs-keyword">if</span> bitsPerDelta &gt; <span class="hljs-number">0</span> {
			bytesPerDelta = (bitsPerDelta + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>
		}

		<span class="hljs-keyword">if</span> pos+<span class="hljs-number">1</span> &gt; <span class="hljs-built_in">cap</span>(compressed) {
			newCap := <span class="hljs-built_in">cap</span>(compressed) * <span class="hljs-number">2</span>
			<span class="hljs-keyword">if</span> newCap == <span class="hljs-number">0</span> {
				newCap = <span class="hljs-number">64</span>
			}
			newBuf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(compressed), newCap)
			<span class="hljs-built_in">copy</span>(newBuf, compressed)
			compressed = newBuf
		}
		compressed = compressed[:pos+<span class="hljs-number">1</span>]
		compressed[pos] = <span class="hljs-type">byte</span>(bytesPerDelta)
		pos++

		<span class="hljs-keyword">if</span> bytesPerDelta == <span class="hljs-number">0</span> {
			<span class="hljs-keyword">continue</span>
		}

		packedBytes := <span class="hljs-built_in">len</span>(block) * bytesPerDelta
		<span class="hljs-keyword">if</span> pos+packedBytes &gt; <span class="hljs-built_in">cap</span>(compressed) {
			newCap := <span class="hljs-built_in">cap</span>(compressed)
			<span class="hljs-keyword">for</span> newCap &lt; pos+packedBytes {
				newCap *= <span class="hljs-number">2</span>
			}
			newBuf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(compressed), newCap)
			<span class="hljs-built_in">copy</span>(newBuf, compressed)
			compressed = newBuf
		}
		compressed = compressed[:pos+packedBytes]

		idx := <span class="hljs-number">0</span>
		<span class="hljs-keyword">switch</span> bytesPerDelta {
		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
			<span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> block {
				compressed[pos+idx] = <span class="hljs-type">byte</span>(d)
				idx++
			}
		<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
			<span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> block {
				binary.LittleEndian.PutUint16(compressed[pos+idx:pos+idx+<span class="hljs-number">2</span>], <span class="hljs-type">uint16</span>(d))
				idx += <span class="hljs-number">2</span>
			}
		<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
			<span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> block {
				compressed[pos+idx] = <span class="hljs-type">byte</span>(d)
				compressed[pos+idx+<span class="hljs-number">1</span>] = <span class="hljs-type">byte</span>(d &gt;&gt; <span class="hljs-number">8</span>)
				compressed[pos+idx+<span class="hljs-number">2</span>] = <span class="hljs-type">byte</span>(d &gt;&gt; <span class="hljs-number">16</span>)
				idx += <span class="hljs-number">3</span>
			}
		<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
			<span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> block {
				binary.LittleEndian.PutUint32(compressed[pos+idx:pos+idx+<span class="hljs-number">4</span>], d)
				idx += <span class="hljs-number">4</span>
			}
		}

		pos += packedBytes
	}

	<span class="hljs-keyword">return</span> compressed[:pos]
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Decompress</span><span class="hljs-params">(compressed []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">uint32</span> {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(compressed) &lt; <span class="hljs-number">8</span> {
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(compressed) &lt; <span class="hljs-number">4</span> {
			<span class="hljs-keyword">return</span> []<span class="hljs-type">uint32</span>{}
		}
		first := binary.LittleEndian.Uint32(compressed[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])
		<span class="hljs-keyword">return</span> []<span class="hljs-type">uint32</span>{first}
	}

	first := binary.LittleEndian.Uint32(compressed[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])
	numDeltas := binary.LittleEndian.Uint32(compressed[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>])
	totalLen := <span class="hljs-type">int</span>(numDeltas) + <span class="hljs-number">1</span>
	result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint32</span>, totalLen)
	<span class="hljs-keyword">if</span> totalLen == <span class="hljs-number">1</span> {
		<span class="hljs-keyword">return</span> result[:<span class="hljs-number">1</span>]
	}

	result[<span class="hljs-number">0</span>] = first
	pos := <span class="hljs-number">8</span>
	remaining := <span class="hljs-type">int</span>(numDeltas)
	prev := first
	currentIdx := <span class="hljs-number">1</span>

	<span class="hljs-keyword">for</span> remaining &gt; <span class="hljs-number">0</span> {
		bytesPerDelta := <span class="hljs-type">int</span>(compressed[pos])
		pos++

		blockSizeCurrent := blockSize
		<span class="hljs-keyword">if</span> remaining &lt; blockSize {
			blockSizeCurrent = remaining
		}
		packedBytes := blockSizeCurrent * bytesPerDelta

		<span class="hljs-keyword">switch</span> bytesPerDelta {
		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
			end := currentIdx + blockSizeCurrent
			value := prev
			<span class="hljs-keyword">for</span> i := currentIdx; i &lt; end; i++ {
				result[i] = value
			}
			currentIdx = end

		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
			p := pos
			endp := pos + blockSizeCurrent
			<span class="hljs-keyword">for</span> p &lt; endp {
				d := <span class="hljs-type">uint32</span>(compressed[p])
				prev += d
				result[currentIdx] = prev
				currentIdx++
				p++
			}

		<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
			p := pos
			endp := pos + <span class="hljs-number">2</span>*blockSizeCurrent
			<span class="hljs-keyword">for</span> p &lt; endp {
				d := <span class="hljs-type">uint32</span>(binary.LittleEndian.Uint16(compressed[p:]))
				prev += d
				result[currentIdx] = prev
				currentIdx++
				p += <span class="hljs-number">2</span>
			}

		<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
			p := pos
			endp := pos + <span class="hljs-number">3</span>*blockSizeCurrent
			<span class="hljs-keyword">for</span> p &lt; endp {
				d := <span class="hljs-type">uint32</span>(compressed[p]) | (<span class="hljs-type">uint32</span>(compressed[p+<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>) | (<span class="hljs-type">uint32</span>(compressed[p+<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>)
				prev += d
				result[currentIdx] = prev
				currentIdx++
				p += <span class="hljs-number">3</span>
			}

		<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
			p := pos
			endp := pos + <span class="hljs-number">4</span>*blockSizeCurrent
			<span class="hljs-keyword">for</span> p &lt; endp {
				d := binary.LittleEndian.Uint32(compressed[p:])
				prev += d
				result[currentIdx] = prev
				currentIdx++
				p += <span class="hljs-number">4</span>
			}
		}

		remaining -= blockSizeCurrent
		pos += packedBytes
	}

	<span class="hljs-keyword">return</span> result
}
</code></pre>


  <div class="notice promotion">
    <p>Like this article? Get notified of new ones:</p>

    <form
      action="https://app.convertkit.com/forms/6531879/subscriptions"
      method="post"
      data-uid="625243fa5c"
      data-format="inline"
      data-version="5"
    >
      <input
        class="px-1 py-1"
        name="email_address"
        type="text"
        placeholder="Email address"
      />
      <button
        type="submit"
        data-element="submit"
        class="bg-indigo-500 hover:bg-indigo-700 text-white py-1 px-3 rounded"
      >
        Subscribe
      </button>
    </form>
  </div>
</main>
 <footer class="">
  <nav>
    <ul>
      <li>
        ©
        <a class="contrast" href="/">Mathieu Larose</a>
      </li>
      <li>
        <a class="contrast" href="mailto:mathieu@mathieularose.com">Email</a>
      </li>
      <li>
        <a class="contrast" href="https://www.linkedin.com/in/mathieularose/"
          >LinkedIn</a
        >
      </li>
      <li>
        <a class="contrast" href="https://github.com/larose">GitHub</a>
      </li>
      <li>
        <a class="contrast" href="/atom.xml">Atom</a>
      </li>
    </ul>
  </nav>
</footer>


    <!-- Cloudflare Web Analytics -->
    <script
      defer
      src="https://static.cloudflareinsights.com/beacon.min.js"
      data-cf-beacon='{"token": "e36c8a0587da4db0ac82e9037c3fb192"}'
    ></script>
    <!-- End Cloudflare Web Analytics -->
  </body>
</html>
