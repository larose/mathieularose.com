<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Authorization as a Service: Data Filtering is Still Hard</title>

    <meta property="og:title" content="Authorization as a Service: Data Filtering is Still Hard" />




  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2026-01-02T00:00:00.000Z" />

  <meta property="profile:first_name" content="Mathieu">
  <meta property="profile:last_name" content="Larose">


<meta property="og:url" content="https://mathieularose.com/authorization-as-a-service-data-filtering-is-still-hard" />


    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"
    />
    <link rel="stylesheet" href="./main.css" />
    <link rel="me" href="https://mastodon.social/@mathieularose" />
    <link
      href="/atom.xml"
      rel="alternate"
      title="Mathieu Larose"
      type="application/atom+xml"
    />
  </head>

  <body class="">
    <header class="">
  <h1>Mathieu Larose</h1>

  <nav>
    <ul>
      <li><a href="/" class="">Home</a></li>
      <li><a href="/services" class="">Services</a></li>
      <li><a href="/projects" class="">Projects</a></li>
    </ul>
  </nav>
</header>
 

<main>
  <hgroup>
    <h1>Authorization as a Service: Data Filtering is Still Hard</h1>
    <p>January 2026</p>
  </hgroup>

  <p>Authorization as a Service (AaaS) providers like Authzed, Cerbos, OpenFGA, Oso, Permify, and Permit have become popular in the last few years. Their core promise is that by centralizing authorization logic in a dedicated service, you save engineering effort and reduce the risk of authorization bugs. So, instead of building and maintaining your own authorization system, you rely on an external service and focus more on your core business.</p>
<p>This works extremely well for check queries such as &quot;Can Mary view Document 1?&quot;, where the answer is true or false.</p>
<p>However, it's a completely different story for queries like &quot;Which documents can Mary view?&quot;. In these cases, we need to return a list of resources that 1) the user is allowed to access, 2) are filtered by some attributes, and 3) sorted by some criteria, and all of which must be done efficiently.</p>
<p>For some providers, their recommended solutions to handle this type of queries have major gaps that require engineering teams to invest considerable effort and introduce additional complexity to their stack, to the point where we may question whether Authorization as a Service is worth it.</p>
<h2>The Data Filtering Problem</h2>
<p>The data filtering problem can be summarized as &quot;Given a search filter and a sort order, which resources can the user view?&quot;.</p>
<p>A classic example is the Google Drive homepage. Documents can be filtered (e.g., &quot;Show only PDFs&quot;), and sorted (e.g., &quot;Last opened&quot;), and users should only see documents they are authorized to access.</p>
<p>Answering these types of queries is challenging because using an AaaS forces a separation between authorization data and application data. Authorization data lives in the AaaS, where it's used to enforce access control, while application data lives in your database, where it's used for filtering and sorting. Or I should be more precise by saying it's the <em>index</em> of the authorization data and the <em>index</em> of the application data that are separated, because in your database, you already all have the information needed to make authorization decisions, it's not optimized to do so.</p>
<p>This is because the main job of an AaaS is to build an index that efficiently answers authorization queries, while the main job of your database is to build an index that efficiently answers application queries.</p>
<p>As a result, we end up with two separate data silos. The challenge is finding a way to combine these indexes to efficiently serve queries like &quot;Given a search filter and a sort order (application data), which resources can the user view (authorization data)?&quot;.</p>
<h2>Solutions proposed by the AaaS providers</h2>
<p>So let's look at the solutions that AaaS providers propose for the data filtering problem. I've written a summary below, but you can find more details in the references at the end of this post.</p>
<h3>1. Search, then check</h3>
<p>In this approach, you first query your database for potential resource IDs based on your filters and sort order. Then you pass this list to the authorization service to check which ones the user can access.</p>
<p>This method works well when your search results are small, but it does not scale when the database returns thousands or millions of resources, which is the case for most real-world use cases.</p>
<h3>2. Check, then search</h3>
<p>It's similar to the previous solution, but the order is reversed. You first ask the authorization service for all the resources the user is allowed to access. Then you filter and sort these results using your database.</p>
<p>This method only works efficiently if the user has access to a relatively small number of resources. Otherwise, you run into the same problem as before: transferring a huge list of IDs between the authorization service and your database does not scale.</p>
<h3>3. Build a local index, then search</h3>
<p>This strategy involves maintaining a local copy of the AaaS index in your database. You do this by listening to updates from the authorization service and indexing them locally. With both the authorization index and your application data index in the same location, you can join them efficiently to answer queries.</p>
<p>Unlike the previous two approaches, this method can scale. However, it adds complexity to your system because you need to maintain a copy of the authorization index. Most providers expect you to handle this yourself and provide very few details on how to implement it effectively. Some providers, like Authzed, offer a managed index that handles the local copy for you, but it doesn't seem be generally available yet.</p>
<p>A question I keep coming back to is whether this setup is really worth it. I send authorization data to the AaaS only to receive it back so I can index it locally. Would it make more sense to skip the AaaS entirely and use an authorization library that handles indexing directly within my system?</p>
<h4>4. Get filter criteria, then search</h4>
<p>Instead of asking the AaaS for a list of authorized resource IDs, you request a list of authorized filters and you then apply these filters in your database query.</p>
<p>Like the previous solution, this approach also has the potential to scale, but in practice you'll have integration work to translate the authorization filter into actual <code>WHERE</code> clauses and <code>JOIN</code> clauses.</p>
<h2>Discussion</h2>
<p>To me, it is not clear that AaaS providers drastically deliver on their promise of saving time and reducing authorization bugs. They certainly help, and conceptually I think they have the right approach. They have definitely helped me over the years to think more clearly about how to model authorization. But I feel we aren't yet at the stage of having &quot;solved&quot; authorization to the point of offering it as a service.</p>
<p>As usual, it depends on your use case. If your authorization queries are mainly check queries (e.g., &quot;Can Mary view document 1?&quot;) and you need to scale these check queries, then an AaaS is an interesting offering.</p>
<p>But if a large portion of your authorization queries involve filtering on resources (e.g., &quot;What documents can Mary view?&quot;), then the scalability feature of the AaaS is largely voided. For these queries, the authorization load will be on your own servers (whether you choose the &quot;build a local index&quot; solution or the &quot;get filter criteria&quot; solution).</p>
<p>In cases like that, the benefits of a service would probably be better realized through a library. The problem is that libraries aren't easily monetizable. So the industry keeps pushing &quot;services&quot; even when a library would be a better technical fit.</p>
<p>It will be interesting to see how the space evolves and how providers improve their solutions for the data filtering problem.</p>
<h2>References</h2>
<p>Authzed:</p>
<ul>
<li><a href="https://authzed.com/docs/spicedb/modeling/protecting-a-list-endpoint#using-materialize">https://authzed.com/docs/spicedb/modeling/protecting-a-list-endpoint#using-materialize</a></li>
<li><a href="https://authzed.com/blog/acl-filtering-in-authzed/">https://authzed.com/blog/acl-filtering-in-authzed/</a></li>
<li><a href="https://authzed.com/docs/spicedb/getting-started/faq#how-do-i-filter-resources-based-on-access-decisions-in-spicedb">https://authzed.com/docs/spicedb/getting-started/faq#how-do-i-filter-resources-based-on-access-decisions-in-spicedb</a></li>
<li><a href="https://authzed.com/products/authzed-materialize">https://authzed.com/products/authzed-materialize</a></li>
</ul>
<p>Cerbos:</p>
<ul>
<li><a href="https://www.cerbos.dev/features-benefits-and-use-cases/permission-aware-data-filtering">https://www.cerbos.dev/features-benefits-and-use-cases/permission-aware-data-filtering</a></li>
</ul>
<p>Google's Zanzibar:</p>
<ul>
<li><a href="https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/">https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/</a></li>
</ul>
<p>OpenFGA:</p>
<ul>
<li><a href="https://openfga.dev/docs/interacting/search-with-permissions">https://openfga.dev/docs/interacting/search-with-permissions</a></li>
<li><a href="https://openfga.dev/docs/best-practices/source-of-truth">https://openfga.dev/docs/best-practices/source-of-truth</a></li>
</ul>
<p>Oso:</p>
<ul>
<li><a href="https://www.osohq.com/docs/develop/enforce/list-filtering#local-list-filtering">https://www.osohq.com/docs/develop/enforce/list-filtering#local-list-filtering</a></li>
</ul>
<p>Permify:</p>
<ul>
<li><a href="https://docs.permify.co/api-reference/permission/lookup-entity#lookup-entity-data-filtering">https://docs.permify.co/api-reference/permission/lookup-entity#lookup-entity-data-filtering</a></li>
<li><a href="https://docs.permify.co/api-reference/permission/lookup-entity">https://docs.permify.co/api-reference/permission/lookup-entity</a></li>
<li><a href="https://github.com/Permify/permify/issues/2681">https://github.com/Permify/permify/issues/2681</a></li>
<li><a href="https://github.com/Permify/permify/issues/412">https://github.com/Permify/permify/issues/412</a></li>
</ul>
<p>Permit:</p>
<ul>
<li><a href="https://docs.permit.io/how-to/enforce-permissions/data-filtering">https://docs.permit.io/how-to/enforce-permissions/data-filtering</a></li>
</ul>


  <div class="notice promotion">
    <p>Like this article? Get notified of new ones:</p>

    <form
      action="https://app.convertkit.com/forms/6531879/subscriptions"
      method="post"
      data-uid="625243fa5c"
      data-format="inline"
      data-version="5"
    >
      <input
        class="px-1 py-1"
        name="email_address"
        type="text"
        placeholder="Email address"
      />
      <button
        type="submit"
        data-element="submit"
        class="bg-indigo-500 hover:bg-indigo-700 text-white py-1 px-3 rounded"
      >
        Subscribe
      </button>
    </form>
  </div>
</main>
 <footer class="">
  <nav>
    <ul>
      <li>
        Â©
        <a class="contrast" href="/">Mathieu Larose</a>
      </li>
      <li>
        <a class="contrast" href="mailto:mathieu@mathieularose.com">Email</a>
      </li>
      <li>
        <a class="contrast" href="https://www.linkedin.com/in/mathieularose/"
          >LinkedIn</a
        >
      </li>
      <li>
        <a class="contrast" href="https://github.com/larose">GitHub</a>
      </li>
      <li>
        <a class="contrast" href="/atom.xml">Atom</a>
      </li>
    </ul>
  </nav>
</footer>


    <!-- Cloudflare Web Analytics -->
    <script
      defer
      src="https://static.cloudflareinsights.com/beacon.min.js"
      data-cf-beacon='{"token": "e36c8a0587da4db0ac82e9037c3fb192"}'
    ></script>
    <!-- End Cloudflare Web Analytics -->
  </body>
</html>
